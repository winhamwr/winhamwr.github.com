## Specific Sprint Goals

I think specificity is important when establishing these kind of sprint goals.
A goal of "working tools" is arbitrary, 
as you don't even know what working actually means until you try to accomplish something valuable. 
I'd also be sad if I didn't see at least a couple of pull request for the zero'th sprint, 
even if the PR is very simple 
(it almost certainly should be  simple and <250 lines of code).

I would really, 
really like to see Github Issues created for the specific tasks 
with a bullet-point specification ASAP. 
hen, 
pull requests targeted at those specific issues, 
which are merged not by the engineer(s) that wrote the code, 
but by either myself 
or someone else on the team after code review is performed. 

I'm not sure which git workflow models you're familiar with, 
but I encourage a process similar to this: 
[Contributing to WYMeditor](http://wymeditor.readthedocs.org/en/v1.0.0-beta.8/wymeditor_development/contributing.html)

## Mentor and Team Relationships

And just a quick meta level braindump regarding my ideal working relationship/understanding, 
I see our relative comparative advantages on this project:

### Mentor

* Representation for eventual end-users of this tool. By End-users, I mean other developers who will see the demo version of this tool and incorporate it into another application for actual end-users.
* High-level technical guidance around libraries, tools, methodology
* High-level guidance on best practices for creating a sustainable, usable, marketable FOSS project that will actually be adopted by other folks. I want your work to have impact.
* Code review to help you everyone improve their javascript skills

### Shared

* Code ownership
* Prioritization and allocation of priorities to sprints
* Breaking large, 
  potentially amorphous and procrastination-baity tasks in to small, 
  objective, 
  actionable Github Issues that take one engineer 
  or one pair-programming engineering team 
  less than 1 8-hour day's worth of effort. 
  This is maybe the most valuable skill you can learn in software engineering 
  and requires a lot of trial and error 
  to build up pattern recognition for the "right' size of task.

### Team

* Final decision on specific tool/library choices
* Deep technical research and understanding 
  of how to accomplish the high level goals. 
  Translating structured HTML to a git repo structure 
  in a way that best supports diffing, 
  merging, 
  etc. is a hard problem that will require deep insight.
* Making all of the hundreds of ultra-important important implementation decisions 
  about how best to solve this problem in code
* Writing testable, 
  maintainable javascript to implement the Github Issues
* Dividing the actionable tasks among team members according to skills/interest
* Coordinating completion of tasks
